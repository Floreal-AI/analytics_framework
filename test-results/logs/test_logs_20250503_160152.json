{
  "logs": [
    {
      "timestamp": "2025-05-03T16:01:52.020459",
      "level": "INFO",
      "message": "Starting test session",
      "metadata": {
        "test_dir": "/Users/admin/Documents/PersonalProjects/bittensor/analytics_framework/test-results"
      }
    },
    {
      "timestamp": "2025-05-03T16:01:52.025002",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.040991",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.047903",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.053779",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.058162",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=32, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=32, out_features=16, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=16, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.062757",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.067953",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.073260",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.074846",
      "level": "ERROR",
      "message": "Error in forward: mat1 and mat2 shapes cannot be multiplied (1x0 and 40x16)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.079096",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.104647",
      "level": "INFO",
      "message": "Epoch 1/1 - train_loss: 0.5000, train_acc: 0.2500, val_loss: 0.5000, val_acc: 0.2500",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.107437",
      "level": "INFO",
      "message": "Saved model checkpoint to /private/var/folders/wg/544yksrd18q2wtz1fyftdm400000gn/T/pytest-of-admin/pytest-9/test_save_model0/checkpoints/test_model.pt",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.110641",
      "level": "INFO",
      "message": "Loaded model checkpoint from /private/var/folders/wg/544yksrd18q2wtz1fyftdm400000gn/T/pytest-of-admin/pytest-9/test_load_model0/checkpoints/test_model.pt",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.178940",
      "level": "ERROR",
      "message": "Missing required features: ['session_id']",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.180273",
      "level": "ERROR",
      "message": "Feature type validation errors: ['has_target_entity must be 0 or 1, got not_an_int']",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.182100",
      "level": "WARNING",
      "message": "Feature hour_of_day could not be converted to float",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.269687",
      "level": "INFO",
      "message": "Test session completed",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T16:01:52.627660",
      "level": "INFO",
      "message": "Test session finished with exit status 1",
      "metadata": {
        "exitstatus": 1,
        "test_counts": {
          "total": 52,
          "passed": 36,
          "failed": 1,
          "skipped": 0,
          "errors": 0
        },
        "duration": 0.6832008361816406,
        "failed_tests": [
          {
            "name": "tests/unit/validator/test_forward.py::TestForward::test_forward",
            "duration": 0.006612500001210719,
            "error_message": "self = <test_forward.TestForward object at 0x12c0c3490>\nsample_features = {'agent_messages_count': 7, 'avg_agent_response_time_seconds': 7.5, 'avg_entity_confidence': 0.87, 'avg_message_length_agent': 55.6, ...}\n\n    @pytest.mark.asyncio\n    async def test_forward(self, sample_features):\n        \"\"\"Test the main forward function.\"\"\"\n        # Create a mock response\n        response = ConversionSynapse(\n            features=sample_features,\n            prediction={'conversion_happened': 1, 'time_to_conversion_seconds': 70.0},\n            confidence=0.8,\n            response_time=0.0,\n            miner_uid=0\n        )\n    \n        # Create our own validator instance\n        validator = MagicMock()\n        validator.dendrite = AsyncMock()\n        validator.dendrite.query = AsyncMock(return_value=[response])\n        validator.update_scores = MagicMock()\n        validator.conversation_history = {}\n        validator.metagraph = MagicMock()\n        validator.metagraph.axons = [MagicMock()]\n    \n        # Mock generate_ground_truth directly in the current module's namespace\n        # instead of trying to patch it from conversion_subnet.validator.forward\n        mock_ground_truth = {'conversion_happened': 1, 'time_to_conversion_seconds': 60.0}\n    \n        # Override behavior with a simple test\n        with patch('conversion_subnet.utils.uids.get_random_uids', return_value=[0]):\n            with patch('conversion_subnet.validator.generate.generate_conversation', return_value=sample_features):\n                with patch('conversion_subnet.validator.utils.validate_features', return_value=sample_features):\n                    with patch(__name__ + '.generate_ground_truth', return_value=mock_ground_truth):\n                        # Call the forward function\n>                       await forward(validator)\n\ntests/unit/validator/test_forward.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nconversion_subnet/validator/forward.py:28: in forward\n    miner_uids = get_random_uids(self, k=sample_size)\nconversion_subnet/utils/uids.py:45: in get_random_uids\n    uid_is_available = check_uid_availability(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmetagraph = <MagicMock name='mock.metagraph' id='5033724464'>, uid = 0\nvpermit_tao_limit = <MagicMock name='mock.config.neuron.vpermit_tao_limit' id='5034720992'>\n\n    def check_uid_availability(\n        metagraph: \"bt.metagraph.Metagraph\", uid: int, vpermit_tao_limit: int\n    ) -> bool:\n        \"\"\"Check if uid is available. The UID should be available if it is serving and has less than vpermit_tao_limit stake\n        Args:\n            metagraph (:obj: bt.metagraph.Metagraph): Metagraph object\n            uid (int): uid to be checked\n            vpermit_tao_limit (int): Validator permit tao limit\n        Returns:\n            bool: True if uid is available, False otherwise\n        \"\"\"\n        # Filter non serving axons.\n        if not metagraph.axons[uid].is_serving:\n            return False\n        # Filter validator permit > 1024 stake.\n        if metagraph.validator_permit[uid]:\n>           if metagraph.S[uid] > vpermit_tao_limit:\nE           TypeError: '>' not supported between instances of 'MagicMock' and 'MagicMock'\n\nconversion_subnet/utils/uids.py:23: TypeError"
          }
        ]
      }
    }
  ],
  "metadata": {
    "generated_at": "2025-05-03T16:01:52.720603",
    "log_count": 19
  }
}