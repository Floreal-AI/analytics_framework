{
  "logs": [
    {
      "timestamp": "2025-05-03T15:49:25.128294",
      "level": "INFO",
      "message": "Starting test session",
      "metadata": {
        "test_dir": "/Users/admin/Documents/PersonalProjects/bittensor/analytics_framework/test-results"
      }
    },
    {
      "timestamp": "2025-05-03T15:49:25.137601",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.141884",
      "level": "ERROR",
      "message": "Error in forward: too many dimensions 'str'",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.226942",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.228840",
      "level": "ERROR",
      "message": "Error in forward: too many dimensions 'str'",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.237369",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.312204",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.316925",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=32, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=32, out_features=16, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=16, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.321423",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.322690",
      "level": "ERROR",
      "message": "Error in forward: too many dimensions 'str'",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.330772",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.332033",
      "level": "ERROR",
      "message": "Error in forward: too many dimensions 'str'",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.340000",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.341109",
      "level": "ERROR",
      "message": "Error in forward: too many dimensions 'str'",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.349137",
      "level": "INFO",
      "message": "Initialized binary classification miner with model: Sequential(\n  (0): Linear(in_features=40, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=1, bias=True)\n  (5): Sigmoid()\n)",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.584493",
      "level": "INFO",
      "message": "Saved model checkpoint to /private/var/folders/wg/544yksrd18q2wtz1fyftdm400000gn/T/pytest-of-admin/pytest-3/test_save_model0/checkpoints/test_model.pt",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.587265",
      "level": "INFO",
      "message": "Saved model checkpoint to /private/var/folders/wg/544yksrd18q2wtz1fyftdm400000gn/T/pytest-of-admin/pytest-3/test_load_model0/checkpoints/test_model.pt",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.719585",
      "level": "ERROR",
      "message": "Missing required features: ['session_id']",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.721094",
      "level": "ERROR",
      "message": "Feature type validation errors: ['has_target_entity must be 0 or 1, got not_an_int']",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.723319",
      "level": "WARNING",
      "message": "Feature hour_of_day could not be converted to float",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:25.934099",
      "level": "INFO",
      "message": "Test session completed",
      "metadata": {}
    },
    {
      "timestamp": "2025-05-03T15:49:26.347618",
      "level": "INFO",
      "message": "Test session finished with exit status 1",
      "metadata": {
        "exitstatus": 1,
        "test_counts": {
          "total": 52,
          "passed": 42,
          "failed": 10,
          "skipped": 0,
          "errors": 0
        },
        "duration": 1.403696060180664,
        "failed_tests": [
          {
            "name": "tests/integration/test_miner_validator.py::TestMinerValidatorIntegration::test_miner_response_to_validator",
            "duration": 0.0037281250042724423,
            "error_message": "self = <test_miner_validator.TestMinerValidatorIntegration object at 0x12d009840>\nmock_miner = <conversion_subnet.miner.miner.BinaryClassificationMiner object at 0x12d0bfa00>\nsample_features = {'agent_messages_count': 7, 'avg_agent_response_time_seconds': 7.5, 'avg_entity_confidence': 0.87, 'avg_message_length_agent': 55.6, ...}\n\n    async def test_miner_response_to_validator(self, mock_miner, sample_features):\n        \"\"\"Test that miner can process features and return valid response.\"\"\"\n        # Create a sample synapse with features\n        synapse = ConversionSynapse(features=sample_features)\n    \n        # Create a mock for the dendrite property\n        mock_dendrite = MagicMock()\n        mock_dendrite.hotkey = \"test_hotkey\"\n    \n        # Patch the synapse directly\n        synapse.__dict__['dendrite'] = mock_dendrite\n    \n        # Mock the metagraph for the miner\n        mock_miner.metagraph = MagicMock()\n        mock_miner.metagraph.hotkeys = [\"test_hotkey\"]\n    \n        # Mock the model output - positive prediction (0.8)\n        with patch.object(mock_miner.model, '__call__', return_value=torch.tensor([0.8])):\n            # Process synapse\n>           result = await mock_miner.forward(synapse)\nE           TypeError: object dict can't be used in 'await' expression\n\ntests/integration/test_miner_validator.py:41: TypeError"
          },
          {
            "name": "tests/integration/test_miner_validator.py::TestMinerValidatorIntegration::test_validator_evaluation_of_miner_response",
            "duration": 0.001611667001270689,
            "error_message": "self = <test_miner_validator.TestMinerValidatorIntegration object at 0x12d009270>\nmock_miner = <conversion_subnet.miner.miner.BinaryClassificationMiner object at 0x12d057700>\nsample_features = {'agent_messages_count': 7, 'avg_agent_response_time_seconds': 7.5, 'avg_entity_confidence': 0.87, 'avg_message_length_agent': 55.6, ...}\n\n    async def test_validator_evaluation_of_miner_response(self, mock_miner, sample_features):\n        \"\"\"Test that validator can evaluate miner responses correctly.\"\"\"\n        # Create a sample synapse with features\n        synapse = ConversionSynapse(features=sample_features)\n    \n        # Create a mock for the dendrite property\n        mock_dendrite = MagicMock()\n        mock_dendrite.hotkey = \"test_hotkey\"\n    \n        # Patch the synapse directly\n        synapse.__dict__['dendrite'] = mock_dendrite\n    \n        # Mock the metagraph for the miner\n        mock_miner.metagraph = MagicMock()\n        mock_miner.metagraph.hotkeys = [\"test_hotkey\"]\n    \n        # Generate ground truth\n        ground_truth = generate_ground_truth(sample_features)\n    \n        # Mock the model output\n        with patch.object(mock_miner.model, '__call__', return_value=torch.tensor([0.8])):\n            # Process synapse with miner\n>           response = await mock_miner.forward(synapse)\nE           TypeError: object dict can't be used in 'await' expression\n\ntests/integration/test_miner_validator.py:76: TypeError"
          },
          {
            "name": "tests/integration/test_miner_validator.py::TestMinerValidatorIntegration::test_miner_validator_end_to_end",
            "duration": 0.00228320799942594,
            "error_message": "self = <test_miner_validator.TestMinerValidatorIntegration object at 0x12d008e80>\nmock_miner = <conversion_subnet.miner.miner.BinaryClassificationMiner object at 0x12d1bfdc0>\nsample_features = {'agent_messages_count': 7, 'avg_agent_response_time_seconds': 7.5, 'avg_entity_confidence': 0.87, 'avg_message_length_agent': 55.6, ...}\n\n    async def test_miner_validator_end_to_end(self, mock_miner, sample_features):\n        \"\"\"Test end-to-end flow from validator query to miner to reward calculation.\"\"\"\n        # Create a mock validator with dendrite\n        validator = MagicMock()\n        validator.dendrite = AsyncMock()\n        validator.metagraph = MagicMock()\n        validator.metagraph.axons = [MagicMock()]\n        validator.update_scores = MagicMock()\n        validator.conversation_history = {}\n    \n        # Mock get_random_uids to return [0]\n>       with patch('conversion_subnet.validator.forward.get_random_uids', return_value=[0]):\n\ntests/integration/test_miner_validator.py:104: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../../../.pyenv/versions/3.10.15/lib/python3.10/unittest/mock.py:1447: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <unittest.mock._patch object at 0x12d0578b0>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n>           raise AttributeError(\n                \"%s does not have the attribute %r\" % (target, name)\n            )\nE           AttributeError: <function forward at 0x12aa848b0> does not have the attribute 'get_random_uids'\n\n../../../../.pyenv/versions/3.10.15/lib/python3.10/unittest/mock.py:1420: AttributeError"
          },
          {
            "name": "tests/unit/miner/test_miner.py::TestBinaryClassificationMiner::test_forward",
            "duration": 0.0013791669989586808,
            "error_message": "self = <test_miner.TestBinaryClassificationMiner object at 0x12d00b610>\nmock_miner = <conversion_subnet.miner.miner.BinaryClassificationMiner object at 0x12d078d60>\nsample_synapse = ConversionSynapse(features={'session_id': 'test-session-123', 'conversation_duration_seconds': 120.5, 'has_target_enti...ted_questions': 1, 'message_alternation_rate': 0.91}, prediction=None, confidence=None, response_time=0.0, miner_uid=0)\n\n    def test_forward(self, mock_miner, sample_synapse):\n        \"\"\"Test the forward method returns the expected output structure.\"\"\"\n        # Mock the model output\n        with patch.object(mock_miner.model, '__call__', return_value=torch.tensor([0.7])):\n            result = mock_miner.forward(sample_synapse)\n    \n            # Check result structure\n            assert 'conversion_happened' in result\n            assert 'time_to_conversion_seconds' in result\n            assert 'confidence' in result\n    \n            # Check result values\n>           assert result['conversion_happened'] == 1  # 0.7 rounded up\nE           assert 0 == 1\n\ntests/unit/miner/test_miner.py:57: AssertionError"
          },
          {
            "name": "tests/unit/miner/test_miner.py::TestBinaryClassificationMiner::test_forward_negative_case",
            "duration": 0.001178666003397666,
            "error_message": "self = <test_miner.TestBinaryClassificationMiner object at 0x12d00b790>\nmock_miner = <conversion_subnet.miner.miner.BinaryClassificationMiner object at 0x12d0bf8b0>\nsample_synapse = ConversionSynapse(features={'session_id': 'test-session-123', 'conversation_duration_seconds': 120.5, 'has_target_enti...ted_questions': 1, 'message_alternation_rate': 0.91}, prediction=None, confidence=None, response_time=0.0, miner_uid=0)\n\n    def test_forward_negative_case(self, mock_miner, sample_synapse):\n        \"\"\"Test the forward method with a negative prediction.\"\"\"\n        # Mock the model output for negative case\n        with patch.object(mock_miner.model, '__call__', return_value=torch.tensor([0.3])):\n            result = mock_miner.forward(sample_synapse)\n    \n            assert result['conversion_happened'] == 0  # 0.3 rounded down\n            assert result['time_to_conversion_seconds'] == -1.0  # Negative for no conversion\n>           assert result['confidence'] == 0.3\nE           assert 0.0 == 0.3\n\ntests/unit/miner/test_miner.py:69: AssertionError"
          },
          {
            "name": "tests/unit/miner/test_miner.py::TestBinaryClassificationMiner::test_forward_exception_handling",
            "duration": 0.0011001250022673048,
            "error_message": "self = <test_miner.TestBinaryClassificationMiner object at 0x12d00b250>\nmock_miner = <conversion_subnet.miner.miner.BinaryClassificationMiner object at 0x12d0bc220>\nsample_synapse = ConversionSynapse(features={'session_id': 'test-session-123', 'conversation_duration_seconds': 120.5, 'has_target_enti...ted_questions': 1, 'message_alternation_rate': 0.91}, prediction=None, confidence=None, response_time=0.0, miner_uid=0)\n\n    def test_forward_exception_handling(self, mock_miner, sample_synapse):\n        \"\"\"Test that exceptions in forward are handled properly.\"\"\"\n        # Mock the model to raise an exception\n        with patch.object(mock_miner.model, '__call__', side_effect=RuntimeError(\"Test error\")):\n            result = mock_miner.forward(sample_synapse)\n    \n            # Should return safe defaults\n            assert result['conversion_happened'] == 0\n            assert result['time_to_conversion_seconds'] == -1.0\n>           assert 'confidence' not in result  # Confidence should not be included in error case\nE           AssertionError: assert 'confidence' not in {'confidence': 0.0, 'conversion_happened': 0, 'time_to_conversion_seconds': -1.0}\n\ntests/unit/miner/test_miner.py:80: AssertionError"
          },
          {
            "name": "tests/unit/miner/test_train.py::TestModelTraining::test_train_model",
            "duration": 0.005503957996552344,
            "error_message": "self = <test_train.TestModelTraining object at 0x12d0fa020>\nmock_adam = <MagicMock name='Adam' id='5050587536'>\nmock_dataloader = <MagicMock name='DataLoader' id='5050592288'>\nsample_dataset = (array([[0.02058449, 0.96990985, 0.83244264, 0.21233911, 0.18182497,\n        0.18340451, 0.30424224, 0.52475643, 0.431...3200496 ,\n        0.89552323, 0.38920168, 0.01083765, 0.90538198, 0.09128668]]), array([0, 1, 1, 0, 1, 1, 0, 1, 0, 1]))\n\n    @patch('torch.utils.data.DataLoader')\n    @patch('torch.optim.Adam')\n    def test_train_model(self, mock_adam, mock_dataloader, sample_dataset):\n        \"\"\"Test train_model function.\"\"\"\n        X_train, y_train = sample_dataset\n        X_val, y_val = sample_dataset  # Reuse for validation\n    \n        # Create mock miner with mock model\n        mock_miner = MagicMock()\n        mock_model = MagicMock()\n        mock_miner.model = mock_model\n    \n        # Mock DataLoader instances\n        mock_train_loader = MagicMock()\n        mock_val_loader = MagicMock()\n        mock_dataloader.side_effect = [mock_train_loader, mock_val_loader]\n    \n        # Mock optimizer\n        mock_optimizer = MagicMock()\n        mock_adam.return_value = mock_optimizer\n    \n        # Configure mock_train_loader to yield sample data\n        sample_batch = (torch.randn(4, 40), torch.randint(0, 2, (4,)).float())\n        mock_train_loader.__iter__.return_value = [sample_batch]\n        mock_train_loader.__len__.return_value = 1\n    \n        # Configure mock_val_loader to yield sample data\n        mock_val_loader.__iter__.return_value = [sample_batch]\n        mock_val_loader.__len__.return_value = 1\n    \n        # Call train_model\n>       history = train_model(\n            miner=mock_miner,\n            X_train=X_train,\n            y_train=y_train,\n            X_val=X_val,\n            y_val=y_val,\n            epochs=1,\n            batch_size=4,\n            learning_rate=0.001,\n            device=\"cpu\"\n        )\n\ntests/unit/miner/test_train.py:147: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nconversion_subnet/miner/train.py:160: in train_model\n    loss = criterion(outputs, labels)\n../../../../.local/share/virtualenvs/analytics_framework-X_C0rfF4/lib/python3.10/site-packages/torch/nn/modules/module.py:1751: in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n../../../../.local/share/virtualenvs/analytics_framework-X_C0rfF4/lib/python3.10/site-packages/torch/nn/modules/module.py:1762: in _call_impl\n    return forward_call(*args, **kwargs)\n../../../../.local/share/virtualenvs/analytics_framework-X_C0rfF4/lib/python3.10/site-packages/torch/nn/modules/loss.py:699: in forward\n    return F.binary_cross_entropy(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ninput = <MagicMock name='mock.model().squeeze()' id='5052202576'>, target = tensor([1., 0., 1., 1.])\nweight = None, size_average = None, reduce = None, reduction = 'mean'\n\n    def binary_cross_entropy(\n        input: Tensor,\n        target: Tensor,\n        weight: Optional[Tensor] = None,\n        size_average: Optional[bool] = None,\n        reduce: Optional[bool] = None,\n        reduction: str = \"mean\",\n    ) -> Tensor:\n        r\"\"\"Measure Binary Cross Entropy between the target and input probabilities.\n    \n        See :class:`~torch.nn.BCELoss` for details.\n    \n        Args:\n            input: Tensor of arbitrary shape as probabilities.\n            target: Tensor of the same shape as input with values between 0 and 1.\n            weight (Tensor, optional): a manual rescaling weight\n                    if provided it's repeated to match input tensor shape\n            size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n                the losses are averaged over each loss element in the batch. Note that for\n                some losses, there multiple elements per sample. If the field :attr:`size_average`\n                is set to ``False``, the losses are instead summed for each minibatch. Ignored\n                when reduce is ``False``. Default: ``True``\n            reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n                losses are averaged or summed over observations for each minibatch depending\n                on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n                batch element instead and ignores :attr:`size_average`. Default: ``True``\n            reduction (str, optional): Specifies the reduction to apply to the output:\n                ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n                ``'mean'``: the sum of the output will be divided by the number of\n                elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n                and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n                specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n    \n        Examples::\n    \n            >>> input = torch.randn(3, 2, requires_grad=True)\n            >>> target = torch.rand(3, 2, requires_grad=False)\n            >>> loss = F.binary_cross_entropy(torch.sigmoid(input), target)\n            >>> loss.backward()\n        \"\"\"\n        if has_torch_function_variadic(input, target, weight):\n            return handle_torch_function(\n                binary_cross_entropy,\n                (input, target, weight),\n                input,\n                target,\n                weight=weight,\n                size_average=size_average,\n                reduce=reduce,\n                reduction=reduction,\n            )\n        if size_average is not None or reduce is not None:\n            reduction_enum = _Reduction.legacy_get_enum(size_average, reduce)\n        else:\n            reduction_enum = _Reduction.get_enum(reduction)\n        if target.size() != input.size():\n>           raise ValueError(\n                f\"Using a target size ({target.size()}) that is different to the input size ({input.size()}) is deprecated. \"\n                \"Please ensure they have the same size.\"\n            )\nE           ValueError: Using a target size (torch.Size([4])) that is different to the input size (<MagicMock name='mock.model().squeeze().size()' id='5052906896'>) is deprecated. Please ensure they have the same size.\n\n../../../../.local/share/virtualenvs/analytics_framework-X_C0rfF4/lib/python3.10/site-packages/torch/nn/functional.py:3560: ValueError"
          },
          {
            "name": "tests/unit/miner/test_train.py::TestModelTraining::test_load_model",
            "duration": 0.002516582993848715,
            "error_message": "self = <test_train.TestModelTraining object at 0x12d0f9c60>\ntmp_checkpoint_dir = PosixPath('/private/var/folders/wg/544yksrd18q2wtz1fyftdm400000gn/T/pytest-of-admin/pytest-3/test_load_model0/checkpoints')\n\n    def test_load_model(self, tmp_checkpoint_dir):\n        \"\"\"Test load_model function.\"\"\"\n        # Create mock miner with mock model\n        mock_miner = MagicMock()\n        mock_model = MagicMock()\n        mock_miner.model = mock_model\n    \n        # Mock state_dict to return a dictionary\n        mock_model.state_dict.return_value = {\"layer1.weight\": torch.randn(5, 5)}\n    \n        # Save a model first\n        save_model(mock_miner, tmp_checkpoint_dir, \"test_model.pt\")\n    \n        # Call load_model\n>       load_model(mock_miner, tmp_checkpoint_dir / \"test_model.pt\")\n\ntests/unit/miner/test_train.py:208: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nconversion_subnet/miner/train.py:253: in load_model\n    miner.model.load_state_dict(torch.load(checkpoint_path, map_location=miner.device))\n../../../../.local/share/virtualenvs/analytics_framework-X_C0rfF4/lib/python3.10/site-packages/torch/serialization.py:1516: in load\n    return _load(\n../../../../.local/share/virtualenvs/analytics_framework-X_C0rfF4/lib/python3.10/site-packages/torch/serialization.py:2114: in _load\n    result = unpickler.load()\n../../../../.local/share/virtualenvs/analytics_framework-X_C0rfF4/lib/python3.10/site-packages/torch/_weights_only_unpickler.py:532: in load\n    self.append(self.persistent_load(pid))\n../../../../.local/share/virtualenvs/analytics_framework-X_C0rfF4/lib/python3.10/site-packages/torch/serialization.py:2078: in persistent_load\n    typed_storage = load_tensor(\n../../../../.local/share/virtualenvs/analytics_framework-X_C0rfF4/lib/python3.10/site-packages/torch/serialization.py:2049: in load_tensor\n    typed_storage = torch.storage.TypedStorage(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <[AttributeError(\"'torch.storage.TypedStorage' object has no attribute '_untyped_storage'\") raised in repr()] TypedStorage object at 0x12d2c8fd0>\ndevice = None, dtype = torch.float32, wrap_storage = <MagicMock name='mock.device()' id='5052873072'>\n_internal = True\n\n    def __init__(\n        self,\n        *args,\n        device=None,\n        dtype=None,\n        wrap_storage=None,\n        _internal=False,\n    ):\n        if not _internal:\n            _warn_typed_storage_removal()\n        arg_error_msg = (\n            \"TypedStorage.__init__ received an invalid combination \"\n            \"of arguments. Expected one of:\\n\"\n            \" * (*, torch.device device, torch.dtype dtype)\\n\"\n            \" * (int size, *, torch.device device, torch.dtype dtype)\\n\"\n            \" * (Sequence data, *, torch.device device, torch.dtype dtype)\\n\"\n            \" * (*, UntypedStorage wrap_storage, torch.dtype dtype)\"\n        )\n    \n        if wrap_storage is not None:\n            if len(args) != 0:\n                raise RuntimeError(\n                    arg_error_msg\n                    + \"\\nNo positional arguments should be given when using \"\n                    \"'wrap_storage'\"\n                )\n    \n            if dtype is None:\n                raise RuntimeError(\n                    arg_error_msg + \"\\nArgument 'dtype' must be specified\"\n                )\n    \n            if not isinstance(dtype, torch.dtype):\n                raise TypeError(\n                    arg_error_msg\n                    + f\"\\nArgument 'dtype' must be torch.dtype, not {type(dtype)}\"\n                )\n    \n            if device is not None:\n                raise RuntimeError(\n                    arg_error_msg\n                    + \"\\nArgument 'device' should not be specified when 'wrap_storage' is given\"\n                )\n    \n            self.dtype = dtype\n    \n            if not isinstance(wrap_storage, torch.UntypedStorage):\n>               raise TypeError(\n                    arg_error_msg\n                    + f\"\\nArgument 'wrap_storage' must be UntypedStorage, but got {type(wrap_storage)}\"\n                )\nE               TypeError: TypedStorage.__init__ received an invalid combination of arguments. Expected one of:\nE                * (*, torch.device device, torch.dtype dtype)\nE                * (int size, *, torch.device device, torch.dtype dtype)\nE                * (Sequence data, *, torch.device device, torch.dtype dtype)\nE                * (*, UntypedStorage wrap_storage, torch.dtype dtype)\nE               Argument 'wrap_storage' must be UntypedStorage, but got <class 'unittest.mock.MagicMock'>\n\n../../../../.local/share/virtualenvs/analytics_framework-X_C0rfF4/lib/python3.10/site-packages/torch/storage.py:827: TypeError"
          },
          {
            "name": "tests/unit/validator/test_forward.py::TestForward::test_forward",
            "duration": 0.000633415998890996,
            "error_message": "self = <Coroutine test_forward>\n\n    def runtest(self) -> None:\n        self.obj = wrap_in_sync(\n            # https://github.com/pytest-dev/pytest-asyncio/issues/596\n            self.obj,  # type: ignore[has-type]\n        )\n>       super().runtest()\n\n../../../../.local/share/virtualenvs/analytics_framework-X_C0rfF4/lib/python3.10/site-packages/pytest_asyncio/plugin.py:549: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../../../.local/share/virtualenvs/analytics_framework-X_C0rfF4/lib/python3.10/site-packages/pytest_asyncio/plugin.py:1069: in inner\n    _loop.run_until_complete(task)\n../../../../.pyenv/versions/3.10.15/lib/python3.10/asyncio/base_events.py:649: in run_until_complete\n    return future.result()\n../../../../.pyenv/versions/3.10.15/lib/python3.10/unittest/mock.py:1393: in patched\n    with self.decoration_helper(patched,\n../../../../.pyenv/versions/3.10.15/lib/python3.10/contextlib.py:135: in __enter__\n    return next(self.gen)\n../../../../.pyenv/versions/3.10.15/lib/python3.10/unittest/mock.py:1358: in decoration_helper\n    arg = exit_stack.enter_context(patching)\n../../../../.pyenv/versions/3.10.15/lib/python3.10/contextlib.py:492: in enter_context\n    result = _cm_type.__enter__(cm)\n../../../../.pyenv/versions/3.10.15/lib/python3.10/unittest/mock.py:1447: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <unittest.mock._patch object at 0x12d0fbeb0>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n>           raise AttributeError(\n                \"%s does not have the attribute %r\" % (target, name)\n            )\nE           AttributeError: <function forward at 0x12aa848b0> does not have the attribute 'generate_conversation'\n\n../../../../.pyenv/versions/3.10.15/lib/python3.10/unittest/mock.py:1420: AttributeError"
          },
          {
            "name": "tests/unit/validator/test_reward.py::TestValidator::test_diversity_reward",
            "duration": 0.0002426249993732199,
            "error_message": "self = <test_reward.TestValidator object at 0x12d0be860>\n\n    def test_diversity_reward(self):\n        \"\"\"Test diversity reward calculation.\"\"\"\n        validator = Validator()\n    \n        # Conservative prediction (0.5) should have 0 diversity reward\n>       assert validator.diversity_reward(0.5) == 0.0\nE       assert 0.5 == 0.0\nE        +  where 0.5 = diversity_reward(0.5)\nE        +    where diversity_reward = <conversion_subnet.validator.reward.Validator object at 0x12d438460>.diversity_reward\n\ntests/unit/validator/test_reward.py:107: AssertionError"
          }
        ]
      }
    }
  ],
  "metadata": {
    "generated_at": "2025-05-03T15:49:26.398144",
    "log_count": 22
  }
}