{
  "exitstatus": 1,
  "test_counts": {
    "total": 4,
    "passed": 1,
    "failed": 3,
    "skipped": 0,
    "errors": 0
  },
  "duration": 0.5754051208496094,
  "failed_tests": [
    {
      "name": "tests/unit/miner/test_miner.py::TestBinaryClassificationMiner::test_forward",
      "duration": 0.002318167003977578,
      "error_message": "self = <test_miner.TestBinaryClassificationMiner object at 0x1513edcc0>\nmock_miner = <conversion_subnet.miner.miner.BinaryClassificationMiner object at 0x1513ec400>\nsample_synapse = ConversionSynapse(features={'session_id': 'test-session-123', 'conversation_duration_seconds': 120.5, 'has_target_enti...ted_questions': 1, 'message_alternation_rate': 0.91}, prediction=None, confidence=None, response_time=0.0, miner_uid=0)\n\n    def test_forward(self, mock_miner, sample_synapse):\n        \"\"\"Test the forward method returns the expected output structure.\"\"\"\n        # Mock the model output\n        with patch.object(mock_miner.model, '__call__', return_value=torch.tensor([0.7])):\n            result = mock_miner.forward(sample_synapse)\n    \n            # Check result structure\n            assert 'conversion_happened' in result\n            assert 'time_to_conversion_seconds' in result\n            assert 'confidence' in result\n    \n            # Check result values\n>           assert result['conversion_happened'] == 1  # 0.7 rounded up\nE           assert 0 == 1\n\ntests/unit/miner/test_miner.py:57: AssertionError"
    },
    {
      "name": "tests/unit/miner/test_miner.py::TestBinaryClassificationMiner::test_forward_negative_case",
      "duration": 0.0010976670018862933,
      "error_message": "self = <test_miner.TestBinaryClassificationMiner object at 0x1513ee350>\nmock_miner = <conversion_subnet.miner.miner.BinaryClassificationMiner object at 0x151433ee0>\nsample_synapse = ConversionSynapse(features={'session_id': 'test-session-123', 'conversation_duration_seconds': 120.5, 'has_target_enti...ted_questions': 1, 'message_alternation_rate': 0.91}, prediction=None, confidence=None, response_time=0.0, miner_uid=0)\n\n    def test_forward_negative_case(self, mock_miner, sample_synapse):\n        \"\"\"Test the forward method with a negative prediction.\"\"\"\n        # Mock the model output for negative case\n        with patch.object(mock_miner.model, '__call__', return_value=torch.tensor([0.3])):\n            result = mock_miner.forward(sample_synapse)\n    \n            assert result['conversion_happened'] == 0  # 0.3 rounded down\n            assert result['time_to_conversion_seconds'] == -1.0  # Negative for no conversion\n>           assert result['confidence'] == 0.3\nE           assert 0.0 == 0.3\n\ntests/unit/miner/test_miner.py:69: AssertionError"
    },
    {
      "name": "tests/unit/validator/test_reward.py::TestValidator::test_diversity_reward",
      "duration": 0.00024033299996517599,
      "error_message": "self = <test_reward.TestValidator object at 0x1513ede40>\n\n    def test_diversity_reward(self):\n        \"\"\"Test diversity reward calculation.\"\"\"\n        validator = Validator()\n    \n        # Conservative prediction (0.5) should have 0 diversity reward\n        assert validator.diversity_reward(0.5) == 0.0\n    \n        # Bold prediction (0.0 or 1.0) should have max diversity reward\n>       assert validator.diversity_reward(0.0) == 0.5\nE       assert 0.0 == 0.5\nE        +  where 0.0 = diversity_reward(0.0)\nE        +    where diversity_reward = <conversion_subnet.validator.reward.Validator object at 0x1514b3c40>.diversity_reward\n\ntests/unit/validator/test_reward.py:110: AssertionError"
    }
  ]
}