{
  "exitstatus": 1,
  "test_counts": {
    "total": 4,
    "passed": 2,
    "failed": 2,
    "skipped": 0,
    "errors": 0
  },
  "duration": 0.5294249057769775,
  "failed_tests": [
    {
      "name": "tests/unit/miner/test_miner.py::TestBinaryClassificationMiner::test_forward",
      "duration": 0.005349375001969747,
      "error_message": "self = <test_miner.TestBinaryClassificationMiner object at 0x11862e8f0>\nmock_miner = <conversion_subnet.miner.miner.BinaryClassificationMiner object at 0x11862ceb0>\nsample_synapse = ConversionSynapse(features={}, prediction=None, confidence=None, response_time=0.0, miner_uid=0)\n\n    def test_forward(self, mock_miner, sample_synapse):\n        \"\"\"Test the forward method returns the expected output structure.\"\"\"\n        # Create a simple mock features dictionary with numeric values\n        mock_features = {f'feature_{i}': float(i) for i in range(40)}\n        sample_synapse.features = mock_features\n    \n        # Mock the model output\n        with patch.object(mock_miner.model, '__call__', return_value=torch.tensor([0.7])):\n            result = mock_miner.forward(sample_synapse)\n    \n            # Check result structure\n            assert 'conversion_happened' in result\n            assert 'time_to_conversion_seconds' in result\n            assert 'confidence' in result\n    \n            # Check result values\n>           assert result['conversion_happened'] == 1  # 0.7 rounded up\nE           assert 0 == 1\n\ntests/unit/miner/test_miner.py:61: AssertionError"
    },
    {
      "name": "tests/unit/miner/test_miner.py::TestBinaryClassificationMiner::test_forward_negative_case",
      "duration": 0.0011865830019814894,
      "error_message": "self = <test_miner.TestBinaryClassificationMiner object at 0x11862eda0>\nmock_miner = <conversion_subnet.miner.miner.BinaryClassificationMiner object at 0x11866feb0>\nsample_synapse = ConversionSynapse(features={}, prediction=None, confidence=None, response_time=0.0, miner_uid=0)\n\n    def test_forward_negative_case(self, mock_miner, sample_synapse):\n        \"\"\"Test the forward method with a negative prediction.\"\"\"\n        # Create a simple mock features dictionary with numeric values\n        mock_features = {f'feature_{i}': float(i) for i in range(40)}\n        sample_synapse.features = mock_features\n    \n        # Mock the model output for negative case\n        with patch.object(mock_miner.model, '__call__', return_value=torch.tensor([0.3])):\n            result = mock_miner.forward(sample_synapse)\n    \n            assert result['conversion_happened'] == 0  # 0.3 rounded down\n            assert result['time_to_conversion_seconds'] == -1.0  # Negative for no conversion\n>           assert result['confidence'] == 0.3\nE           assert 0.0 == 0.3\n\ntests/unit/miner/test_miner.py:77: AssertionError"
    }
  ]
}