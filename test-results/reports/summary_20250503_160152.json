{
  "exitstatus": 1,
  "test_counts": {
    "total": 52,
    "passed": 36,
    "failed": 1,
    "skipped": 0,
    "errors": 0
  },
  "duration": 0.6832008361816406,
  "failed_tests": [
    {
      "name": "tests/unit/validator/test_forward.py::TestForward::test_forward",
      "duration": 0.006612500001210719,
      "error_message": "self = <test_forward.TestForward object at 0x12c0c3490>\nsample_features = {'agent_messages_count': 7, 'avg_agent_response_time_seconds': 7.5, 'avg_entity_confidence': 0.87, 'avg_message_length_agent': 55.6, ...}\n\n    @pytest.mark.asyncio\n    async def test_forward(self, sample_features):\n        \"\"\"Test the main forward function.\"\"\"\n        # Create a mock response\n        response = ConversionSynapse(\n            features=sample_features,\n            prediction={'conversion_happened': 1, 'time_to_conversion_seconds': 70.0},\n            confidence=0.8,\n            response_time=0.0,\n            miner_uid=0\n        )\n    \n        # Create our own validator instance\n        validator = MagicMock()\n        validator.dendrite = AsyncMock()\n        validator.dendrite.query = AsyncMock(return_value=[response])\n        validator.update_scores = MagicMock()\n        validator.conversation_history = {}\n        validator.metagraph = MagicMock()\n        validator.metagraph.axons = [MagicMock()]\n    \n        # Mock generate_ground_truth directly in the current module's namespace\n        # instead of trying to patch it from conversion_subnet.validator.forward\n        mock_ground_truth = {'conversion_happened': 1, 'time_to_conversion_seconds': 60.0}\n    \n        # Override behavior with a simple test\n        with patch('conversion_subnet.utils.uids.get_random_uids', return_value=[0]):\n            with patch('conversion_subnet.validator.generate.generate_conversation', return_value=sample_features):\n                with patch('conversion_subnet.validator.utils.validate_features', return_value=sample_features):\n                    with patch(__name__ + '.generate_ground_truth', return_value=mock_ground_truth):\n                        # Call the forward function\n>                       await forward(validator)\n\ntests/unit/validator/test_forward.py:148: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nconversion_subnet/validator/forward.py:28: in forward\n    miner_uids = get_random_uids(self, k=sample_size)\nconversion_subnet/utils/uids.py:45: in get_random_uids\n    uid_is_available = check_uid_availability(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmetagraph = <MagicMock name='mock.metagraph' id='5033724464'>, uid = 0\nvpermit_tao_limit = <MagicMock name='mock.config.neuron.vpermit_tao_limit' id='5034720992'>\n\n    def check_uid_availability(\n        metagraph: \"bt.metagraph.Metagraph\", uid: int, vpermit_tao_limit: int\n    ) -> bool:\n        \"\"\"Check if uid is available. The UID should be available if it is serving and has less than vpermit_tao_limit stake\n        Args:\n            metagraph (:obj: bt.metagraph.Metagraph): Metagraph object\n            uid (int): uid to be checked\n            vpermit_tao_limit (int): Validator permit tao limit\n        Returns:\n            bool: True if uid is available, False otherwise\n        \"\"\"\n        # Filter non serving axons.\n        if not metagraph.axons[uid].is_serving:\n            return False\n        # Filter validator permit > 1024 stake.\n        if metagraph.validator_permit[uid]:\n>           if metagraph.S[uid] > vpermit_tao_limit:\nE           TypeError: '>' not supported between instances of 'MagicMock' and 'MagicMock'\n\nconversion_subnet/utils/uids.py:23: TypeError"
    }
  ]
}